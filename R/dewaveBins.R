#########################################################################/**
# @RdocFunction dewaveBins
#
# @alias dewaveBins,QDNAseqCopyNumbers-method
#
# @title "Corrects binned read counts for waves caused by genetic variation based on replication timing profiles"
#
# @synopsis
#
# \description{
#     @get "title".
# }
#
# \arguments{
#     \item{object}{A @see "QDNAseqCopyNumbers" object with \code{copynumber}
#         data.}
#     \item{user.calibration}{Allowing users to use their own calibration set for wave correction,
#           generated by using @see "createNormalCalibration" }
#     \item{force}{Running this function will remove possible segmentation and
#         calling results. When they are present, running requires specifying
#         \code{force} is @TRUE.}
# }
#
# \value{
#     Returns a @see "QDNAseqCopyNumbers" object with the assay data element
#     \code{copynumber} corrected for genomic waves.
# }
#
# \examples{
# data(LGG150)
# readCounts <- LGG150
# readCountsFiltered <- applyFilters(readCounts)
# readCountsFiltered <- estimateCorrection(readCountsFiltered)
# copyNumbers <- correctBins(readCountsFiltered)
# copyNumbersDewaved <- dewaveBins(copyNumbers)
# }
#
# @author "MC"
#
# @keyword manip
#*/#########################################################################
setMethod('dewaveBins', signature=c(object='QDNAseqCopyNumbers'),
          definition=function(object, user.calibration=FALSE, force=FALSE) {
            
            # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            # Validate arguments
            # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            # Argument "object":
            if (!force && ("segmented" %in% assayDataElementNames(object)))
              stop("Data has already been segmented. Re-normalizing will ",
                   "remove segmentation (and possible calling) results. ",
                   "Please specify force=TRUE, if you want this.")
            
            if ("segmented" %in% assayDataElementNames(object))
              assayDataElement(object, "segmented") <- NULL
            if ("calls" %in% assayDataElementNames(object)) {
              assayDataElement(object, "calls") <- NULL
              assayDataElement(object, "probloss") <- NULL
              assayDataElement(object, "probnorm") <- NULL
              assayDataElement(object, "probgain") <- NULL
              if ("probdloss" %in% assayDataElementNames(object))
                assayDataElement(object, "probdloss") <- NULL
              if ("probamp" %in% assayDataElementNames(object))
                assayDataElement(object, "probamp") <- NULL
            }
            
            
           if (length(user.calibration) > 1) {
              bin_size <- featureData(object)$end[1]-featureData(object)$start[1]+1
              bin_size_calibration <- user.calibration$End[1]-user.calibration$Start[1]+1
              
              print(paste("Bin size used is: ", bin_size/1000, "kb", sep=""))
              print("Using user inputted calibration set")
              
              if (bin_size != bin_size_calibration) {
                stop("Bin size of Tumor set does not equal the bin size of the Calibration set
                     use datasets of same bin size or create your own calibration set using createNormalCalibration()")
              }
              
           }  
            
           else if (user.calibration==FALSE) {
             bin_size <- featureData(object)$end[1]-featureData(object)$start[1]+1
             print(paste("Bin size used is: ", bin_size/1000, "kb", sep=""))
             print("No input calibration set found, using pre-generated calibration set")
             
             if (bin_size == 15000){
               data(NormalCalibrationSet_15kb)
               user.calibration <- NormalCalibrationSet_15kb
             }
             else if (bin_size == 30000){
               data(NormalCalibrationSet_30kb)
               user.calibration <- NormalCalibrationSet_30kb
             }
             else if (bin_size == 100000){
               data(NormalCalibrationSet_100kb)
               user.calibration <- NormalCalibrationSet_100kb
             }
             else if (bin_size == 1000000){
               data(NormalCalibrationSet_1000kb)
               user.calibration <- NormalCalibrationSet_1000kb
             }
             else {
               stop("No calibration set available in selected bin size, please
                    create your own calibration set using createNormalCalibration()")
             }
           }

                        
            #Changes X and Y to chr23/24 for NoWaves
            feature <- featureData(object)
            chromosome <- feature$chromosome
            chromosome <- gsub("X", 23, chromosome)
            chromosome <- gsub("Y", 24, chromosome)
            chromosome <- as.numeric(chromosome)
            
            #Get copynumber from QDNAseqCopyNumbers object and create a dataframe
            start <- feature$start
            end <- feature$end
            
            copynumber <- assayData(object)
            copynumber <- copynumber$copynumber
            copynumber[copynumber==0] <- 1
            copynumber <- log2(copynumber)
            
            dataset <- data.frame(Name=1:nrow(copynumber), Chromosome=as.vector(chromosome), Start=start, End=end)
            dataset <- cbind(dataset, copynumber)
                        
            #Dewave
            
            vmsg("Applying deWaving ... \n", appendLF=FALSE)
            
            input_dewave <- na.omit(dataset)
            
            #check if input dataset is of same dimensions as calibration set
            if (nrow(input_dewave) != nrow(user.calibration)){
              user.calibration <- user.calibration[which(rownames(user.calibration) %in% rownames(input_dewave)),]
              input_dewave <- input_dewave[which(rownames(input_dewave) %in% rownames(user.calibration)),]
              input_dewave$Name <- user.calibration$Name
            }
            
            #Correct tumor profiles
            corrected <- CorrectTumors(input_dewave,user.calibration)
            
            #Insert NAs again
            dataset[which(rownames(dataset) %in% rownames(corrected)),] <- corrected
            
            #remove no sample data (Name,Chromosome,Start,End)
            object_input <- as.matrix(dataset[,-1:-4])
            object_input <- 2^object_input
            object_input <- as.matrix(object_input)
            colnames(object_input) <- colnames(dataset)[5:length(dataset)]
            rownames(object_input) <- rownames(dataset)
                                    
            new("QDNAseqCopyNumbers", copynumber=object_input,phenodata=phenoData(object), bins=featureData(object))
            
          })

# EOF